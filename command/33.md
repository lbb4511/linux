# df

df 命令的功能是用来检查 linux 服务器的文件系统的磁盘空间占用情况。

```sh
df -ha       【-a  显示所有】
df -i        【以inode模式显示磁盘使用情况】
df -h        【列出文件系统的类型】
df -ht ext4  【显示指定类型磁盘】
```

如

```sh
$df
文件系统           1K-块      已用      可用 已用% 挂载点
dev              8157924         0   8157924    0% /dev
run              8165372      1304   8164068    1% /run
/dev/sda3      102686648  25843996  71583440   27% /
tmpfs            8165372    162260   8003112    2% /dev/shm
tmpfs            8165372         0   8165372    0% /sys/fs/cgroup
tmpfs            8165372     88328   8077044    2% /tmp
/dev/sda4      118497728  42102076  70333236   38% /home
/dev/sda1         258096       121    257975    1% /boot/efi
tmpfs            1633072        20   1633052    1% /run/user/1000
/dev/sdb1      871902804 655732408 216170396   76% /run/media/lbb/DATA
/dev/mapper/db 102673396  29391352  68039896   31% /mnt
```

## 主分区和扩展分区

1. 主分区是硬盘的启动分区，他是独立的，也是硬盘的第一个分区。
2. 分出主分区后，其余的部分可以分成扩展分区，一般是剩下的部分全部分成扩展分区，也可以不全分，那剩的部分就浪费了。
3. 但扩展分区是不能直接用的，他是以逻辑分区的方式来使用的，所以说扩展分区可分成若干逻辑分区。他们的关系是包含的关系，所有的逻辑分区都是扩展分区的一部分 。
4. 硬盘的容量＝主分区的容量＋扩展分区的容量；扩展分区的容量＝各个逻辑分区的容量之和。
5. 除去主分区所占用的容量以外，剩下的容量被认定为扩展分区。通俗的讲就是主分区是硬盘的主人，而扩展分区是这个硬盘上的仆人，主分区和扩展分区为主从关系。
6. 扩展分区如果不再进行分区了，那么扩展分区就是逻辑分区了。如果还需要进行分区操作的话，则所谓的逻辑分区只能从扩展分区上操作。就相当于在仆人中（扩展分区上）进行细分类，分成接电话的（D 盘）、扫地的（E 盘）、做饭的（F 盘）等等。

## Linux 硬盘分区、分区、删除分区、格式化、挂载、卸载

先查看下是否有磁盘没有分区

`fdisk -l`

### 开始分区

fdisk /dev/sdb

输入 m，可以查看有哪些操作

输入 p 查看当前硬盘分区，目前没有分区。

输入 n 新建一个分区，输入 p 建立分区，输入分区编号 1

然后会让你设置开始扇区（不知道是否这么解释）：默认回车就是 1 从头开始

然后结束扇区设置 1000 这个值好像决定了分区的大小，我对硬件不是很熟悉。安装上面方法，建立第二个分区

然后打印分区数 输入 p，红色框就是已经建立好的分区

最后保存分区 输入 w

最后，检查分区是否已经建立好！如果出现红色区域，则表示已经建立好了。

其实这个时候，建立好的分区还不能用，还需要挂载才可以用。但是挂载之前，必须要格式化，才行。。。

### 格式化分区

格式化命令：
`mkfs.ext3 /dev/sdb2` 是格式化成 ext3
`mkfs.ext2 /dev/sdb1` 是格式化成 ext2

格式化之后也并不能使用，必须要挂载才行

### 挂载分区

格式化之后，就可以挂载分区了

```sh
mkdir /mnt/d1
mkdir /mnt/d2
mount /dev/sdc1 /mnt/d1
mount /dev/sdc2 /mnt/d2
```

这样就挂载成功，可以正常使用了。

### 卸载分区

umount /dev/sdc2

卸载了，其实还可以挂载，而且数据还会在的

### 删除分区

```sh
fdisk /dev/sdc
m
d
1
d
```

输入 w 保存，这个时候分区以及删除了，可以重新创建了。

## 加密

因为保密需要，一般系统中会在文件和磁盘中进行加密，但是文件的加密比较容易破解，不安全。所以在特殊需要下，会对磁盘进行加密，磁盘加密后在磁盘损坏的同时，其中的数据也会损坏，接下来将会介绍磁盘加密的一些内容。

新建立一个磁盘分区，输入`cryptsetup luksFormat /dev/sdb2`对磁盘分区 /dev/sdb2 进行加密，输入大写的`YES`(一定要大写)后，输入两次密码，即可完成磁盘加密。

完成加密后如果将 sdb2 分区直接挂载，将无法挂载。输入`cryptsetup open /dev/sdb2 we`是将加密的磁盘分区 sdb2 打开为 we，名字可以自行设置，出现`/dev/mapper/we`分区，然后格式化这个分区`mkfs.ext3 /dev/sdb2`，就可以进行挂载了。

挂载在 /mnt 后，在其中建立 10 个文件 file{1..10}，取消挂载后在 /mnt 下看不到这 10 个文件，输入命令`cryptsetup close we`后，可以关闭 sdb2 分区，这时候 we 分区不存在了，也就无法再进行挂载了。

将 sdb2 分区重新打开成其他名称的分区，挂载后会出现上述的 10 个文件。

如果需要开机时自动挂载，需要先在`/root`目录下建立一个记录密码的文件，例如建立`/root/lukswe`，文件名称可自行设定，在其中输入加密分区 sdb2 的密码，为了安全，建议给其设置"600"权限。然后输入命令`cryptsetup luksAddKey /dev/vdb1 /root/lukswe`将密码存放文件与加密磁盘关联。在`/etc/crypttab`文件中写入解密配置文件，例如写入`we /dev/vdb1 /root/lukswe`，we 表示 sdb2 磁盘打开后的名称。最后需要在`/etc/fstab`写入开机自动挂载配置，写入`/dev/mapper/we /mnt xfs defaults 0 0`，完成后重启即可检测是否自动挂载。

需要取消磁盘加密时，需要格式化这个磁盘，如果在之前设置过开机自动挂载，则需要先删除密码记录文件，再删除`/etc/crypttab`和`/etc/fstab`中的配置，取消挂载后，关闭加密磁盘，最后再格式化就可以删除这个加密磁盘了。
